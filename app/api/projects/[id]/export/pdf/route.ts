/**
 * GET /api/projects/[id]/export/pdf
 *
 * 5-page tech pack PDF:
 *   Page 1 — Cover (style info, key specs)
 *   Page 2 — Flat Sketches + confirmed features
 *   Page 3 — POM table (base size)
 *   Page 4 — BOM grouped by category (add ?show_costs=true for pricing)
 *   Page 5 — Colorways placeholder
 */

import { NextRequest, NextResponse } from 'next/server';
import { PDFDocument, StandardFonts, rgb, PageSizes } from 'pdf-lib';
import type { PDFPage, PDFFont, PDFImage } from 'pdf-lib';
import { getProject, getMeasurements, getBomItems, getConstructionNotes } from '@/lib/db';
import { fileExists, readFile, FILES } from '@/lib/storage';
import type { ConfirmedFeatures } from '@/lib/cost/features';

export const runtime = 'nodejs';

// ── Dimensions ────────────────────────────────────────────────────────────────

const [W, H] = PageSizes.A4;  // 595.28 × 841.89 pts
const M  = 40;                 // page margin
const IW = W - M * 2;         // inner width

// ── Colours ───────────────────────────────────────────────────────────────────

const DARK  = rgb(0.11, 0.10, 0.09);   // #1C1917
const WHITE = rgb(1, 1, 1);
const GRAY  = rgb(0.47, 0.44, 0.42);   // text-secondary
const LGRAY = rgb(0.96, 0.96, 0.96);   // table row alt
const BORD  = rgb(0.91, 0.89, 0.88);   // border
const GREEN = rgb(0.09, 0.64, 0.29);   // confirmed

// ── Helpers ───────────────────────────────────────────────────────────────────

function inToCm(n: number) { return Math.round(n * 2.54 * 10) / 10; }

function wordWrap(text: string, font: PDFFont, size: number, maxW: number): string[] {
  const result: string[] = [];
  for (const seg of text.split('\n')) {
    const words = seg.split(' ');
    let line = '';
    for (const word of words) {
      const test = line ? `${line} ${word}` : word;
      if (font.widthOfTextAtSize(test, size) <= maxW) {
        line = test;
      } else {
        if (line) result.push(line);
        line = word;
      }
    }
    if (line) result.push(line);
  }
  return result.length ? result : [''];
}

/** Draw standard page header. Returns Y below header. */
function pageHeader(page: PDFPage, boldFont: PDFFont, font: PDFFont, title: string, subtitle: string): number {
  const hh = 44;
  page.drawRectangle({ x: 0, y: H - hh, width: W, height: hh, color: DARK });
  page.drawText(title,    { x: M, y: H - 28, size: 13, font: boldFont, color: WHITE });
  page.drawText(subtitle, { x: M, y: H - 40, size: 7,  font,           color: GRAY });
  // Fabrica mark
  const mark = 'FABRICA';
  page.drawText(mark, {
    x: W - M - boldFont.widthOfTextAtSize(mark, 8),
    y: H - 34, size: 8, font: boldFont, color: GRAY,
  });
  page.drawText('Generated by Fabrica', { x: M, y: 22, size: 7, font, color: GRAY });
  return H - hh;
}

/** Draw a table and return the Y below it. */
function drawTable(
  page: PDFPage,
  font: PDFFont,
  boldFont: PDFFont,
  headers: string[],
  rows: string[][],
  x: number,
  startY: number,
  colWidths: number[],
  rowH = 18,
): number {
  const tableW  = colWidths.reduce((a, b) => a + b, 0);
  const hdrH    = 20;
  let y = startY;

  // Header
  page.drawRectangle({ x, y: y - hdrH, width: tableW, height: hdrH, color: DARK });
  let cx = x;
  headers.forEach((h, i) => {
    page.drawText(h.toUpperCase(), { x: cx + 5, y: y - hdrH + 6, size: 7, font: boldFont, color: WHITE });
    cx += colWidths[i];
  });
  y -= hdrH;

  rows.forEach((row, ri) => {
    page.drawRectangle({
      x, y: y - rowH, width: tableW, height: rowH,
      color: ri % 2 === 1 ? LGRAY : WHITE,
      borderColor: BORD, borderWidth: 0.3,
    });
    cx = x;
    row.forEach((cell, ci) => {
      page.drawText(String(cell ?? ''), {
        x: cx + 5, y: y - rowH + 5,
        size: 8, font, color: DARK, maxWidth: colWidths[ci] - 8,
      });
      cx += colWidths[ci];
    });
    y -= rowH;
  });

  return y;
}

// ── Route handler ─────────────────────────────────────────────────────────────

const SUB_LABELS: Record<string, string> = {
  oversized_hoodie: 'Oversized Hoodie',
  pullover_hoodie:  'Pullover Hoodie',
  zip_hoodie:       'Zip Hoodie',
  unisex_hoodie:    'Unisex Hoodie',
  crewneck:         'Crewneck Sweatshirt',
  sweatpants:       'Sweatpants',
};

const CATEGORY_LABELS_BOM: Record<string, string> = {
  fabric: 'Fabrics', trim: 'Trims & Hardware', label: 'Labels',
  packaging: 'Packaging', thread: 'Thread',
};

export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } },
) {
  const project = getProject(params.id);
  if (!project) {
    return NextResponse.json({ error: 'Project not found' }, { status: 404 });
  }

  const showCosts  = new URL(req.url).searchParams.get('show_costs') === 'true';
  const measurements = getMeasurements(params.id);
  const bomItems     = getBomItems(params.id);
  const construction = getConstructionNotes(params.id);

  const doc      = await PDFDocument.create();
  const font     = await doc.embedFont(StandardFonts.Helvetica);
  const boldFont = await doc.embedFont(StandardFonts.HelveticaBold);

  // Embed flat sketch images (best-effort)
  // Priority: user-uploaded sketch → AI-generated sketch → original photo
  let imgFront: PDFImage | null = null;
  let imgBack:  PDFImage | null = null;
  if (fileExists(params.id, FILES.SKETCH_FRONT)) {
    try { imgFront = await doc.embedPng(new Uint8Array(readFile(params.id, FILES.SKETCH_FRONT))); } catch {}
  }
  if (!imgFront && fileExists(params.id, FILES.AI_SKETCH_FRONT)) {
    try { imgFront = await doc.embedPng(new Uint8Array(readFile(params.id, FILES.AI_SKETCH_FRONT))); } catch {}
  }
  if (fileExists(params.id, FILES.SKETCH_BACK)) {
    try { imgBack = await doc.embedPng(new Uint8Array(readFile(params.id, FILES.SKETCH_BACK))); } catch {}
  }
  if (!imgBack && fileExists(params.id, FILES.AI_SKETCH_BACK)) {
    try { imgBack = await doc.embedPng(new Uint8Array(readFile(params.id, FILES.AI_SKETCH_BACK))); } catch {}
  }
  // Fall back to original photo if no sketch at all
  if (!imgFront && fileExists(params.id, 'original.png')) {
    try { imgFront = await doc.embedPng(new Uint8Array(readFile(params.id, 'original.png'))); } catch {}
  }

  const typeLabel = project.sub_type ? (SUB_LABELS[project.sub_type] ?? project.sub_type)
                                     : (project.category.charAt(0).toUpperCase() + project.category.slice(1));
  const sizeLabel = project.base_size ?? 'M';
  const dateStr   = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });

  const confirmedFeatures: ConfirmedFeatures | null = project.confirmed_features_json
    ? JSON.parse(project.confirmed_features_json) : null;

  // ── PAGE 1 — Cover ──────────────────────────────────────────────────────────

  {
    const p = doc.addPage(PageSizes.A4);

    // Header band
    p.drawRectangle({ x: 0, y: H - 110, width: W, height: 110, color: DARK });
    p.drawText('TECH PACK', { x: M, y: H - 62, size: 28, font: boldFont, color: WHITE });
    p.drawText('GARMENT SPECIFICATION DOCUMENT', { x: M, y: H - 88, size: 8, font, color: GRAY });
    const mark = 'FABRICA';
    p.drawText(mark, {
      x: W - M - boldFont.widthOfTextAtSize(mark, 8),
      y: H - 88, size: 8, font: boldFont, color: GRAY,
    });

    // Style name
    p.drawText(project.style_name, {
      x: M, y: H - 158, size: 20, font: boldFont, color: DARK, maxWidth: IW,
    });

    // Style number + season
    let metaY = H - 182;
    if (project.style_number) {
      p.drawText(project.style_number, { x: M, y: metaY, size: 10, font, color: GRAY });
      metaY -= 16;
    }
    if (project.season) {
      p.drawText(project.season, { x: M, y: metaY, size: 10, font, color: GRAY });
    }

    // Detail grid (3 items in a row)
    const details: [string, string][] = [
      ['GARMENT TYPE', typeLabel],
      ['BASE SIZE',    sizeLabel],
      ['DATE',         dateStr],
    ];
    const colW = IW / 3;
    details.forEach(([label, value], i) => {
      const dx = M + i * colW;
      const dy = H - 238;
      p.drawText(label, { x: dx, y: dy,      size: 7,  font: boldFont, color: GRAY });
      p.drawText(value, { x: dx, y: dy - 15, size: 10, font,           color: DARK, maxWidth: colW - 8 });
    });

    p.drawLine({ start: { x: M, y: H - 360 }, end: { x: W - M, y: H - 360 }, thickness: 0.5, color: BORD });

    // Contents
    p.drawText('DOCUMENT CONTENTS', { x: M, y: H - 380, size: 7, font: boldFont, color: GRAY });
    const sections: string[] = [];
    if (imgFront || imgBack)       sections.push('Flat Sketches + Confirmed Features');
    if (measurements.length > 0)   sections.push(`Points of Measure — ${measurements.length} points (base size ${sizeLabel})`);
    if (bomItems.length > 0)       sections.push(`Bill of Materials — ${bomItems.length} components${showCosts ? ' with pricing' : ''}`);
    sections.push('Colorways');
    sections.forEach((c, i) => {
      p.drawText(`${i + 2}.  ${c}`, { x: M, y: H - 402 - i * 20, size: 9, font, color: DARK });
    });

    p.drawText('Generated by Fabrica', { x: M, y: 22, size: 7, font, color: GRAY });
  }

  // ── PAGE 2 — Flat Sketches + Features ─────────────────────────────────────

  {
    const p    = doc.addPage(PageSizes.A4);
    const topY = pageHeader(p, boldFont, font, 'FLAT SKETCHES', project.style_name);

    // Sketches (top half)
    const sketchAreaH = 340;
    if (imgFront || imgBack) {
      const areaW = (IW - 20) / 2;
      if (imgFront && imgBack) {
        const df = imgFront.scaleToFit(areaW, sketchAreaH);
        const db = imgBack.scaleToFit(areaW, sketchAreaH);
        p.drawImage(imgFront, { x: M,              y: topY - 10 - df.height, width: df.width, height: df.height });
        p.drawImage(imgBack,  { x: M + areaW + 20, y: topY - 10 - db.height, width: db.width, height: db.height });
        p.drawText('FRONT VIEW', { x: M + areaW / 2 - 22,              y: topY - 12 - df.height - 10, size: 7, font: boldFont, color: GRAY });
        p.drawText('BACK VIEW',  { x: M + areaW + 20 + areaW / 2 - 18, y: topY - 12 - db.height - 10, size: 7, font: boldFont, color: GRAY });
      } else {
        const img  = (imgFront ?? imgBack)!;
        const dims = img.scaleToFit(IW / 2, sketchAreaH);
        p.drawImage(img, { x: M + (IW - dims.width) / 2, y: topY - 10 - dims.height, width: dims.width, height: dims.height });
        p.drawText(imgFront ? 'FRONT VIEW' : 'BACK VIEW', { x: W / 2 - 22, y: topY - 12 - dims.height - 10, size: 7, font: boldFont, color: GRAY });
      }
    } else {
      p.drawRectangle({ x: M, y: topY - 10 - 200, width: IW, height: 200, color: LGRAY, borderColor: BORD, borderWidth: 0.5 });
      p.drawText('No flat sketch uploaded', { x: W / 2 - 50, y: topY - 10 - 105, size: 9, font, color: GRAY });
    }

    // Confirmed features section
    const featY = topY - sketchAreaH - 30;
    p.drawText('CONFIRMED FEATURES', { x: M, y: featY, size: 8, font: boldFont, color: GRAY });
    p.drawLine({ start: { x: M, y: featY - 6 }, end: { x: W - M, y: featY - 6 }, thickness: 0.3, color: BORD });

    if (confirmedFeatures) {
      const featuresList: string[] = [];
      if (confirmedFeatures.hasHood)       featuresList.push(`Hood (${confirmedFeatures.hoodStyle?.replace(/_/g, ' ')})`);
      if (confirmedFeatures.hasDrawcord)   featuresList.push('Drawcord');
      if (confirmedFeatures.hasZipper)     featuresList.push(`Zipper (${confirmedFeatures.zipperType?.replace(/_/g, ' ')})`);
      if (confirmedFeatures.hasPockets)    featuresList.push(`Pockets (${confirmedFeatures.pocketType?.replace(/_/g, ' ')})`);
      if (confirmedFeatures.hasRibCuffs)   featuresList.push('Rib Cuffs');
      if (confirmedFeatures.hasRibHem)     featuresList.push('Rib Hem');
      if (confirmedFeatures.hasThumbHoles) featuresList.push('Thumb Holes');

      const colSize = Math.ceil(featuresList.length / 2);
      featuresList.forEach((feat, i) => {
        const col = Math.floor(i / colSize);
        const row = i % colSize;
        p.drawText(`· ${feat}`, {
          x: M + col * (IW / 2),
          y: featY - 18 - row * 16,
          size: 8, font, color: DARK,
        });
      });

      if (featuresList.length === 0) {
        p.drawText('No features confirmed', { x: M, y: featY - 18, size: 8, font, color: GRAY });
      }
    } else {
      p.drawText('Features not yet confirmed', { x: M, y: featY - 18, size: 8, font, color: GRAY });
    }

    if (construction.length > 0) {
      const noteY = featY - 110;
      p.drawText('AI CONSTRUCTION NOTES', { x: M, y: noteY, size: 8, font: boldFont, color: GRAY });
      p.drawLine({ start: { x: M, y: noteY - 6 }, end: { x: W - M, y: noteY - 6 }, thickness: 0.3, color: BORD });
      let curY = noteY - 20;
      for (const note of construction.slice(0, 3)) {
        if (curY < 40) break;
        p.drawText(note.section.toUpperCase(), { x: M, y: curY, size: 7, font: boldFont, color: DARK });
        curY -= 12;
        const lines = wordWrap(note.content, font, 7.5, IW - 10);
        for (const line of lines.slice(0, 3)) {
          if (curY < 40) break;
          p.drawText(line, { x: M + 8, y: curY, size: 7.5, font, color: DARK });
          curY -= 11;
        }
        curY -= 10;
      }
    }
  }

  // ── PAGE 3 — POM ───────────────────────────────────────────────────────────

  {
    const p    = doc.addPage(PageSizes.A4);
    const topY = pageHeader(p, boldFont, font, 'POINTS OF MEASURE', project.style_name);

    p.drawText(`Base size: ${sizeLabel}  ·  Values in inches (cm shown)`, {
      x: M, y: topY - 12, size: 8, font, color: GRAY,
    });

    if (measurements.length > 0) {
      drawTable(
        p, font, boldFont,
        ['Point of Measure', 'Group', 'Base (in)', 'Base (cm)', 'Tol ±"', 'Notes'],
        measurements.map(m => [
          m.label,
          m.group_name ?? '',
          m.base_value != null ? String(m.base_value) : '—',
          m.base_value != null ? String(inToCm(m.base_value)) : '—',
          m.tolerance != null  ? String(m.tolerance) : '—',
          m.notes ?? '',
        ]),
        M, topY - 28,
        [IW * 0.30, IW * 0.12, IW * 0.12, IW * 0.12, IW * 0.10, IW * 0.24],
      );
    } else {
      p.drawText('No measurements entered yet.', { x: M, y: topY - 40, size: 9, font, color: GRAY });
    }
  }

  // ── PAGE 4 — BOM ───────────────────────────────────────────────────────────

  {
    const p    = doc.addPage(PageSizes.A4);
    const topY = pageHeader(p, boldFont, font, 'BILL OF MATERIALS', project.style_name);

    const BOM_CATEGORY_ORDER = ['fabric', 'trim', 'label', 'packaging', 'thread'];
    let curY = topY - 16;

    if (bomItems.length > 0) {
      for (const cat of BOM_CATEGORY_ORDER) {
        const items = bomItems.filter(i => i.category === cat);
        if (items.length === 0) continue;
        if (curY < 60) break;

        // Category label
        p.drawText(CATEGORY_LABELS_BOM[cat] ?? cat, { x: M, y: curY, size: 8, font: boldFont, color: DARK });
        curY -= 4;
        p.drawLine({ start: { x: M, y: curY }, end: { x: W - M, y: curY }, thickness: 0.3, color: BORD });
        curY -= 4;

        if (showCosts) {
          curY = drawTable(
            p, font, boldFont,
            ['Component', 'Material', 'Composition', '$/unit', 'Qty', 'Waste%', 'Total'],
            items.map(b => [
              b.component,
              b.material,
              b.composition,
              `$${b.unit_price?.toFixed(2) ?? '—'}`,
              String(b.consumption ?? 1),
              `${b.wastage ?? 0}%`,
              `$${b.total_cost?.toFixed(2) ?? '—'}`,
            ]),
            M, curY,
            [IW * 0.17, IW * 0.17, IW * 0.20, IW * 0.09, IW * 0.07, IW * 0.08, IW * 0.10],
          );
        } else {
          curY = drawTable(
            p, font, boldFont,
            ['Component', 'Material', 'Composition', 'Spec', 'Notes'],
            items.map(b => [b.component, b.material, b.composition, b.specification ?? '', b.notes ?? '']),
            M, curY,
            [IW * 0.18, IW * 0.18, IW * 0.24, IW * 0.16, IW * 0.24],
          );
        }
        curY -= 14;
      }
    } else {
      p.drawText('No BOM items entered yet.', { x: M, y: topY - 30, size: 9, font, color: GRAY });
    }
  }

  // ── PAGE 5 — Colorways ─────────────────────────────────────────────────────

  {
    const p    = doc.addPage(PageSizes.A4);
    const topY = pageHeader(p, boldFont, font, 'COLORWAYS', project.style_name);

    p.drawRectangle({
      x: M, y: topY - 200, width: IW, height: 180,
      color: LGRAY, borderColor: BORD, borderWidth: 0.5,
    });
    p.drawText('COLORWAY DETAILS', { x: M + 8, y: topY - 70, size: 9, font: boldFont, color: GRAY });
    p.drawText('Add colorway names, pantone codes, and swatch references here.', {
      x: M + 8, y: topY - 90, size: 8, font, color: GRAY, maxWidth: IW - 16,
    });

    // Placeholder boxes for 3 colorways
    for (let i = 0; i < 3; i++) {
      const bx = M + i * (IW / 3) + 8;
      const by = topY - 180;
      p.drawRectangle({ x: bx, y: by, width: IW / 3 - 16, height: 70, color: WHITE, borderColor: BORD, borderWidth: 0.5 });
      p.drawText(`Colorway ${i + 1}`, { x: bx + 8, y: by + 52, size: 8, font: boldFont, color: DARK });
      p.drawText('Name: _______________', { x: bx + 8, y: by + 38, size: 7, font, color: GRAY });
      p.drawText('Pantone: ____________', { x: bx + 8, y: by + 26, size: 7, font, color: GRAY });
      p.drawText('Fabric ref: _________', { x: bx + 8, y: by + 14, size: 7, font, color: GRAY });
    }
  }

  // ── Serialize ─────────────────────────────────────────────────────────────

  const pdfBytes = await doc.save();
  const slug     = project.style_name.replace(/[^a-z0-9]/gi, '_').toLowerCase().slice(0, 40);

  return new NextResponse(pdfBytes.buffer as ArrayBuffer, {
    headers: {
      'Content-Type':        'application/pdf',
      'Content-Disposition': `attachment; filename="techpack_${slug}.pdf"`,
    },
  });
}
