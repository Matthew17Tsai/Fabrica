/**
 * GET /api/projects/[id]/export/pdf
 * Generates and streams a tech pack PDF with:
 *   - Cover page
 *   - Flat sketches (front + back PNG, if available)
 *   - Points of measure table
 *   - Bill of materials table
 *   - Construction notes
 */
import { NextRequest, NextResponse } from 'next/server';
import { PDFDocument, StandardFonts, rgb, PageSizes } from 'pdf-lib';
import type { PDFPage, PDFFont, PDFImage } from 'pdf-lib';
import { getProject, getMeasurements, getBomItems, getConstructionNotes } from '@/lib/db';
import { fileExists, readFile, FILES } from '@/lib/storage';

export const runtime = 'nodejs';

// ── Dimensions & colours ──────────────────────────────────────────────────────

const [W, H] = PageSizes.A4;   // 595.28 × 841.89 pts
const M   = 40;                 // page margin
const IW  = W - M * 2;         // inner width

const NAVY  = rgb(30  / 255, 58  / 255, 95  / 255);
const WHITE = rgb(1,   1,   1);
const BLACK = rgb(0.1, 0.1, 0.1);
const GRAY  = rgb(0.42, 0.45, 0.50);
const LGRAY = rgb(0.96, 0.96, 0.96);
const BORD  = rgb(0.82, 0.82, 0.82);
const LBLUE = rgb(0.7,  0.8,  0.9);

// ── Helpers ───────────────────────────────────────────────────────────────────

function inToCm(n: number) { return Math.round(n * 2.54 * 10) / 10; }

/** Word-wrap text to fit within maxW points at fontSize. Handles existing newlines. */
function wordWrap(text: string, font: PDFFont, fontSize: number, maxW: number): string[] {
  const result: string[] = [];
  for (const seg of text.split('\n')) {
    const words = seg.split(' ');
    let line = '';
    for (const word of words) {
      const test = line ? `${line} ${word}` : word;
      if (font.widthOfTextAtSize(test, fontSize) <= maxW) {
        line = test;
      } else {
        if (line) result.push(line);
        line = word;
      }
    }
    if (line) result.push(line);
  }
  return result.length ? result : [''];
}

/** Draw the standard page header bar. Returns the Y coordinate below the header. */
function pageHeader(
  page: PDFPage,
  boldFont: PDFFont,
  font: PDFFont,
  title: string,
  subtitle: string,
): number {
  const hh = 50;
  page.drawRectangle({ x: 0, y: H - hh, width: W, height: hh, color: NAVY });
  page.drawText(title,    { x: M, y: H - 33, size: 14, font: boldFont, color: WHITE });
  page.drawText(subtitle, { x: M, y: H - 45, size: 7,  font,           color: LBLUE });
  page.drawText('Generated by Fabrica', { x: M, y: 25, size: 7, font, color: GRAY });
  return H - hh;
}

/**
 * Draw a styled table.
 * @param startY  Y coordinate of the TOP of the table (pdf-lib origin is bottom-left).
 * @returns       Y coordinate of the BOTTOM of the table.
 */
function drawTable(
  page: PDFPage,
  font: PDFFont,
  boldFont: PDFFont,
  headers: string[],
  rows: string[][],
  x: number,
  startY: number,
  colWidths: number[],
  rowH = 18,
): number {
  const tableW   = colWidths.reduce((a, b) => a + b, 0);
  const headerH  = 22;
  let y = startY;

  // Header strip
  page.drawRectangle({ x, y: y - headerH, width: tableW, height: headerH, color: NAVY });
  let cx = x;
  headers.forEach((h, i) => {
    page.drawText(h.toUpperCase(), {
      x: cx + 5, y: y - headerH + 7,
      size: 7, font: boldFont, color: WHITE,
    });
    cx += colWidths[i];
  });
  y -= headerH;

  // Data rows
  rows.forEach((row, ri) => {
    page.drawRectangle({
      x, y: y - rowH, width: tableW, height: rowH,
      color:       ri % 2 === 1 ? LGRAY : WHITE,
      borderColor: BORD,
      borderWidth: 0.3,
    });
    cx = x;
    row.forEach((cell, ci) => {
      page.drawText(String(cell ?? ''), {
        x: cx + 5, y: y - rowH + 5,
        size: 8, font, color: BLACK,
        maxWidth: colWidths[ci] - 8,
      });
      cx += colWidths[ci];
    });
    y -= rowH;
  });

  return y;
}

// ── Route handler ─────────────────────────────────────────────────────────────

const SUB_LABELS: Record<string, string> = {
  oversized_hoodie: 'Oversized Hoodie',
  pullover_hoodie:  'Pullover Hoodie',
  zip_hoodie:       'Zip Hoodie',
  unisex_hoodie:    'Unisex Hoodie',
  crewneck:         'Crewneck Sweatshirt',
  sweatpants:       'Sweatpants',
};

export async function GET(
  _req: NextRequest,
  { params }: { params: { id: string } },
) {
  const project = getProject(params.id);
  if (!project) {
    return NextResponse.json({ error: 'Project not found' }, { status: 404 });
  }

  const measurements = getMeasurements(params.id);
  const bomItems     = getBomItems(params.id);
  const construction = getConstructionNotes(params.id);

  // ── Prepare document ────────────────────────────────────────────────────────

  const doc      = await PDFDocument.create();
  const font     = await doc.embedFont(StandardFonts.Helvetica);
  const boldFont = await doc.embedFont(StandardFonts.HelveticaBold);

  // Embed flat-sketch PNGs (best-effort)
  let imgFront: PDFImage | null = null;
  let imgBack:  PDFImage | null = null;
  if (fileExists(params.id, FILES.FLAT_PNG_FRONT)) {
    try { imgFront = await doc.embedPng(new Uint8Array(readFile(params.id, FILES.FLAT_PNG_FRONT))); } catch {}
  }
  if (fileExists(params.id, FILES.FLAT_PNG_BACK)) {
    try { imgBack  = await doc.embedPng(new Uint8Array(readFile(params.id, FILES.FLAT_PNG_BACK))); } catch {}
  }

  const typeLabel = project.sub_type ? (SUB_LABELS[project.sub_type] ?? project.sub_type)
                                     : (project.category.charAt(0).toUpperCase() + project.category.slice(1));
  const fitLabel  = project.fit  ? (project.fit.charAt(0).toUpperCase()  + project.fit.slice(1))  : 'Regular';
  const sizeLabel = project.base_size ?? 'M';
  const dateStr   = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });

  // ── PAGE 1 — Cover ──────────────────────────────────────────────────────────

  const cover = doc.addPage(PageSizes.A4);

  // Dark header band
  cover.drawRectangle({ x: 0, y: H - 110, width: W, height: 110, color: NAVY });
  cover.drawText('TECH PACK', { x: M, y: H - 62, size: 30, font: boldFont, color: WHITE });
  cover.drawText('GARMENT SPECIFICATION DOCUMENT', { x: M, y: H - 88, size: 9, font, color: LBLUE });
  const fabrica = 'FABRICA';
  cover.drawText(fabrica, {
    x: W - M - font.widthOfTextAtSize(fabrica, 9),
    y: H - 88, size: 9, font: boldFont, color: LBLUE,
  });

  // Project title
  cover.drawText(project.title, {
    x: M, y: H - 165, size: 22, font: boldFont, color: BLACK, maxWidth: IW,
  });

  // Detail grid (2 × 2)
  const detailPairs: [string, string][] = [
    ['GARMENT TYPE', typeLabel],
    ['BASE SIZE',    sizeLabel],
    ['FIT',          fitLabel],
    ['DATE',         dateStr],
  ];
  detailPairs.forEach(([label, value], i) => {
    const col = i % 2;
    const row = Math.floor(i / 2);
    const dx  = M + col * (IW / 2);
    const dy  = H - 220 - row * 55;
    cover.drawText(label, { x: dx, y: dy,      size: 7,  font: boldFont, color: GRAY  });
    cover.drawText(value, { x: dx, y: dy - 16, size: 11, font,           color: BLACK });
  });

  // Divider
  cover.drawLine({ start: { x: M, y: H - 358 }, end: { x: W - M, y: H - 358 }, thickness: 0.5, color: BORD });

  // Contents list
  cover.drawText('DOCUMENT CONTENTS', { x: M, y: H - 378, size: 7, font: boldFont, color: GRAY });
  const contents: string[] = [];
  if (imgFront || imgBack) contents.push('Flat Sketches — front and back views');
  if (measurements.length > 0) contents.push(`Points of Measure — ${measurements.length} measurements`);
  if (bomItems.length > 0)     contents.push(`Bill of Materials — ${bomItems.length} components`);
  if (construction.length > 0) contents.push(`Construction Notes — ${construction.length} sections`);
  if (contents.length === 0)   contents.push('No content generated yet — generate sketches and add measurements.');
  contents.forEach((c, i) => {
    cover.drawText(`·  ${c}`, { x: M, y: H - 400 - i * 20, size: 9, font, color: BLACK });
  });

  cover.drawText('Generated by Fabrica', { x: M, y: 25, size: 7, font, color: GRAY });

  // ── PAGE 2 — Flat Sketches ─────────────────────────────────────────────────

  if (imgFront || imgBack) {
    const sp    = doc.addPage(PageSizes.A4);
    const topY  = pageHeader(sp, boldFont, font, 'FLAT SKETCHES', project.title);
    const areaH = topY - 80;
    const areaW = (IW - 20) / 2;

    if (imgFront && imgBack) {
      const df = imgFront.scaleToFit(areaW, areaH);
      const db = imgBack.scaleToFit(areaW, areaH);
      sp.drawImage(imgFront, { x: M,               y: topY - 10 - df.height, width: df.width, height: df.height });
      sp.drawImage(imgBack,  { x: M + areaW + 20,  y: topY - 10 - db.height, width: db.width, height: db.height });
      sp.drawText('FRONT VIEW', { x: M + areaW / 2 - 22,              y: 55, size: 8, font: boldFont, color: GRAY });
      sp.drawText('BACK VIEW',  { x: M + areaW + 20 + areaW / 2 - 20, y: 55, size: 8, font: boldFont, color: GRAY });
    } else {
      const img  = (imgFront ?? imgBack)!;
      const dims = img.scaleToFit(IW, areaH);
      sp.drawImage(img, { x: M + (IW - dims.width) / 2, y: topY - 10 - dims.height, width: dims.width, height: dims.height });
      sp.drawText(imgFront ? 'FRONT VIEW' : 'BACK VIEW', { x: W / 2 - 22, y: 55, size: 8, font: boldFont, color: GRAY });
    }
  }

  // ── PAGE 3 — Measurements ─────────────────────────────────────────────────

  if (measurements.length > 0) {
    const mp   = doc.addPage(PageSizes.A4);
    const topY = pageHeader(mp, boldFont, font, 'POINTS OF MEASURE', project.title);
    mp.drawText(`Base size: ${sizeLabel}  ·  Fit: ${fitLabel}  ·  Measurements in inches (cm conversion shown)`, {
      x: M, y: topY - 12, size: 8, font, color: GRAY,
    });
    drawTable(
      mp, font, boldFont,
      ['Point of Measure', 'Value (in)', 'Value (cm)', 'Tolerance', 'Notes'],
      measurements.map((m) => [
        m.label,
        m.value_inches != null ? String(m.value_inches) : '—',
        m.value_inches != null ? String(inToCm(m.value_inches)) : '—',
        `±${m.tolerance}"`,
        m.notes ?? '',
      ]),
      M, topY - 26,
      [IW * 0.40, IW * 0.12, IW * 0.12, IW * 0.12, IW * 0.24],
    );
  }

  // ── PAGE 4 — BOM ──────────────────────────────────────────────────────────

  if (bomItems.length > 0) {
    const bp   = doc.addPage(PageSizes.A4);
    const topY = pageHeader(bp, boldFont, font, 'BILL OF MATERIALS', project.title);
    drawTable(
      bp, font, boldFont,
      ['Component', 'Material', 'Composition', 'Weight', 'Color', 'Notes'],
      bomItems.map((b) => [b.component, b.material, b.composition, b.weight, b.color ?? '', b.notes ?? '']),
      M, topY - 10,
      [IW * 0.16, IW * 0.16, IW * 0.22, IW * 0.12, IW * 0.12, IW * 0.22],
    );
  }

  // ── PAGE 5 — Construction Notes ───────────────────────────────────────────

  if (construction.length > 0) {
    const cp      = doc.addPage(PageSizes.A4);
    const topY    = pageHeader(cp, boldFont, font, 'CONSTRUCTION NOTES', project.title);
    let   curY    = topY - 16;
    const lineH   = 12;
    const secGap  = 16;
    const contentFontSize = 8;
    const contentMaxW = IW - 10;

    for (const note of construction) {
      if (curY < 50) break;

      // Section heading
      cp.drawText(note.section.toUpperCase(), {
        x: M, y: curY, size: 9, font: boldFont, color: NAVY,
      });
      curY -= lineH + 2;

      // Wrapped content
      const lines = wordWrap(note.content, font, contentFontSize, contentMaxW);
      for (const line of lines) {
        if (curY < 50) break;
        cp.drawText(line, { x: M + 8, y: curY, size: contentFontSize, font, color: BLACK });
        curY -= lineH;
      }
      curY -= secGap;
    }
  }

  // ── Serialize ─────────────────────────────────────────────────────────────

  const pdfBytes = await doc.save();
  const slug     = project.title.replace(/[^a-z0-9]/gi, '_').toLowerCase().slice(0, 40);

  // doc.save() returns Uint8Array — pass underlying ArrayBuffer as BodyInit
  return new NextResponse(pdfBytes.buffer as ArrayBuffer, {
    headers: {
      'Content-Type':        'application/pdf',
      'Content-Disposition': `attachment; filename="techpack_${slug}.pdf"`,
    },
  });
}
